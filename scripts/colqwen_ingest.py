#!/usr/bin/env python
"""
colqwen_ingest.py

Creates a Weaviate collection with multi-vector support for ColQwen2.5 embeddings
and ingests PDF pages as multi-vector representations.

Usage:
    python scripts/colqwen_ingest.py data/uk_firmware.pdf "UK Firmware Manual"
"""

import sys
import os
from pathlib import Path
import torch
from PIL import Image
import weaviate
from weaviate.classes.config import Configure, Property, DataType
from colpali_engine.models import ColQwen2_5, ColQwen2_5_Processor

COLLECTION_NAME = "PDFDocuments"  # ColQwen collection name

def initialize_colqwen(device="mps"):
    """Initialize ColQwen2.5 model for multi-vector embedding generation."""
    print(f"[ColQwen] Loading ColQwen2.5 model on {device}...")
    
    model = ColQwen2_5.from_pretrained(
        "vidore/colqwen2.5-v0.2",
        dtype=torch.bfloat16,
        device_map=device,
    ).eval()
    
    processor = ColQwen2_5_Processor.from_pretrained("vidore/colqwen2.5-v0.2")
    
    print("[ColQwen] Model loaded successfully")
    return model, processor

def create_multivector_collection(client: weaviate.WeaviateClient):
    """Create or recreate Weaviate collection with multi-vector configuration."""
    existing = client.collections.list_all()
    
    if COLLECTION_NAME in existing:
        print(f"[Weaviate] Deleting existing collection {COLLECTION_NAME}...")
        client.collections.delete(COLLECTION_NAME)
    
    print(f"[Weaviate] Creating collection {COLLECTION_NAME} with multi-vector config...")
    
    # Create collection with multi-vector support
    # Using user-provided vectors (we generate embeddings externally)
    coll = client.collections.create(
        name=COLLECTION_NAME,
        properties=[
            Property(name="page_id", data_type=DataType.INT),
            Property(name="asset_manual", data_type=DataType.TEXT),
            Property(name="page_number", data_type=DataType.INT),
            Property(name="image_path", data_type=DataType.TEXT, skip_vectorization=True),
        ],
        # Multi-vector configuration
        # Note: Weaviate v4 Python client uses different syntax
        # We'll use standard vector config and provide multi-vectors as list[list[float]]
    )
    
    print(f"[Weaviate] Collection {COLLECTION_NAME} created successfully")
    return coll

def load_preview_images(manual_name: str) -> list[Image.Image]:
    """
    Load existing preview PNG images instead of converting PDF.
    This reuses the images generated by generate_previews.py.
    """
    # Convert manual name to directory name (e.g., "UK Firmware Manual" -> "uk_firmware")
    dir_name = manual_name.lower().replace(' ', '_')
    preview_dir = Path(f"static/previews/{dir_name}")
    
    if not preview_dir.exists():
        raise FileNotFoundError(
            f"Preview directory not found: {preview_dir}\n"
            f"Please run: python scripts/generate_previews.py <pdf_path> static/previews/{dir_name}"
        )
    
    # Load all page-*.png files in order
    image_files = sorted(preview_dir.glob("page-*.png"), key=lambda p: int(p.stem.split('-')[1]))
    
    if not image_files:
        raise FileNotFoundError(f"No PNG preview images found in {preview_dir}")
    
    print(f"[Preview] Loading {len(image_files)} preview images from {preview_dir}...")
    images = [Image.open(img_path) for img_path in image_files]
    print(f"[Preview] Loaded {len(images)} images")
    
    return images

def generate_multivector_embeddings(images: list[Image.Image], model, processor, device="mps"):
    """Generate multi-vector embeddings for PDF pages."""
    print(f"[ColQwen] Generating multi-vector embeddings for {len(images)} pages...")
    
    embeddings = []
    
    # Process in batches to manage memory
    batch_size = 4
    for i in range(0, len(images), batch_size):
        batch = images[i:i+batch_size]
        
        # Process batch
        batch_input = processor.process_images(batch).to(device)
        
        with torch.no_grad():
            batch_embeddings = model(**batch_input)
        
        # Each embedding is shape (seq_len, embed_dim) - this is the multi-vector
        for emb in batch_embeddings:
            # Convert to CPU and numpy for Weaviate
            embeddings.append(emb.cpu().numpy())
        
        print(f"[ColQwen] Processed pages {i+1}-{min(i+batch_size, len(images))}/{len(images)}")
    
    return embeddings

def ingest_pages(client, manual_name: str, images: list[Image.Image], embeddings: list):
    """Ingest PDF pages with multi-vector embeddings into Weaviate."""
    coll = client.collections.get(COLLECTION_NAME)
    
    print(f"[Weaviate] Ingesting {len(images)} pages for {manual_name}...")
    
    with coll.batch.fixed_size(batch_size=10) as batch:
        for page_num, (image, embedding) in enumerate(zip(images, embeddings), start=1):
            # Weaviate expects multi-vector as list of lists
            multi_vector = embedding.tolist()  # Convert numpy to list
            
            props = {
                "page_id": page_num,
                "asset_manual": manual_name,
                "page_number": page_num,
                "image_path": f"static/previews/{manual_name.lower().replace(' ', '_')}/page-{page_num}.png",
            }
            
            # Add object with multi-vector embedding
            batch.add_object(properties=props, vector=multi_vector)
    
    print(f"[Weaviate] Ingestion complete: {len(images)} pages")

def main():
    if len(sys.argv) < 2:
        print("Usage: python scripts/colqwen_ingest.py <manual_name>")
        print("Example: python scripts/colqwen_ingest.py 'UK Firmware Manual'")
        print("\nNote: Preview PNGs must exist in static/previews/<manual_name>/")
        print("Run generate_previews.py first if needed.")
        sys.exit(1)
    
    manual_name = sys.argv[1]
    
    # Determine device
    if torch.backends.mps.is_available():
        device = "mps"
    elif torch.cuda.is_available():
        device = "cuda:0"
    else:
        device = "cpu"
    
    print(f"[System] Using device: {device}")
    
    # Initialize ColQwen
    model, processor = initialize_colqwen(device)
    
    # Load existing preview images (much faster than PDF conversion!)
    images = load_preview_images(manual_name)
    
    # Generate multi-vector embeddings
    embeddings = generate_multivector_embeddings(images, model, processor, device)
    
    # Connect to Weaviate and create collection
    with weaviate.connect_to_local() as client:
        create_multivector_collection(client)
        
        # Ingest pages
        ingest_pages(client, manual_name, images, embeddings)
    
    print("[Complete] ColQwen ingestion finished successfully")

if __name__ == "__main__":
    main()
