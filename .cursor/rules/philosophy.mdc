---
alwaysApply: true
---

# Philosophy & Vision

## Core Principles
1. **Local-first** - All inference on M3 256GB Mac Studio
2. **Native Ollama** - Must run natively (not Docker) to access full RAM/Metal
3. **Dual-pipeline** - Text RAG (bge-m3) + ColQwen (visual) stay separate
4. **Visual grounding** - BBoxes and page images are core, not optional

## Memory Budget (M3 256GB)
| Model | Size | Notes |
|-------|------|-------|
| gpt-oss-120B | ~65GB | LLM for decisions + text generation |
| bge-m3 | ~1.2GB | Embeddings (8K context, retrieval-optimized) |
| Qwen3-VL-8B | ~8GB | VLM for visual interpretation (MLX) |
| ColQwen2.5-v0.2 | ~4GB | Visual retrieval (PyTorch) |
| **Total** | ~78GB | Leaves 178GB for KV cache |

## Agent Architecture (Elysia-inspired)

### Decision Loop
```
User Query → LLM Decision → Tool Execution → Result
                ↑                              ↓
                └──── Self-healing if error ───┘
```

### Tool Pattern
```python
class Tool:
    async def __call__(self, tree_data, inputs) -> AsyncGenerator:
        yield Result(
            objects=[...],
            metadata={"query": query},
            llm_message="Found {n} results"  # For LLM context
        )
```

### Environment (Centralized State)
```python
environment[tool_name][result_name] = [{"objects": [...], "metadata": {...}}]
```

## What We DON'T Use
- **Dockerized Ollama** - Can't access full RAM/GPU
- **Multiple LLMs** - Single gpt-oss for all text tasks

## DSPy Migration (PLANNED)
> See `PLAN_DSPY_MIGRATION.md` and `TODO.md` for implementation details

**Status:** Planning complete, implementation not started

**Why DSPy:**
- Structured prompts with typed I/O (no manual JSON parsing)
- Auto-optimization with MIPROv2
- LLM-as-Judge for semantic evaluation
- Context injection pattern (VSMChainOfThought)

**Key Additions:**
- `api/knowledge/` - Atlas + domain knowledge (ThorGuard)
- `api/prompts/` - DSPy Signatures
- `api/evaluation/` - Judge service + metrics
- `api/endpoints/benchmark.py` - Interactive benchmark API

## Anti-Patterns
- Don't add abstractions for one-time operations
- Don't future-proof hypothetical requirements
- Don't refactor unrelated code when fixing bugs
